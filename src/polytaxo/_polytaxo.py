import abc
import fnmatch
import functools
import itertools
import operator as op
import re
import shlex
from collections import defaultdict
from textwrap import indent
from typing import (
    Any,
    Dict,
    Generic,
    Iterable,
    Iterator,
    List,
    Literal,
    Mapping,
    Optional,
    Sequence,
    Set,
    Tuple,
    TypeVar,
    Union,
)


class NodeNotFoundError(Exception):
    """Exception raised when a node is not found."""

    pass


class ConflictError(Exception):
    """Exception raised when descriptors are incompatible."""

    pass


T = TypeVar("T")
TOnConflictLiteral = Literal["replace", "raise", "skip"]


class Descriptor(abc.ABC):
    """Abstract base class for descriptors."""

    @property
    @abc.abstractmethod
    def unique_id(self):  # pragma: no cover
        """Return a unique identifier for the descriptor."""
        ...

    @abc.abstractmethod
    def negate(self, negate: bool = True) -> "Descriptor":  # pragma: no cover
        """Negate the descriptor."""
        ...

    @abc.abstractmethod
    def format(self, anchor: Optional["PrimaryNode"] = None) -> str:
        """Format the descriptor as a string."""
        ...

    def __invert__(self):
        return self.negate()

    def __le__(self, other) -> bool:  # pragma: no cover
        """Return True if self is implied by other."""
        if isinstance(other, PolyDescription):
            for other_descriptor in other.descriptors:
                if self <= other_descriptor:
                    return True
            return False

        return NotImplemented

    def __eq__(self, other: object) -> bool:
        if type(self) != type(other):
            return False

        return self.unique_id == other.unique_id  # type: ignore

    def __hash__(self) -> int:
        return hash(self.unique_id)

    def __repr__(self) -> str:
        return f"<{self.__class__.__name__} {self.format()}>"

    def __str__(self) -> str:
        return self.format()


class NeverDescriptor(Descriptor):
    """A descriptor that is never implied by another (even itself)."""

    @property
    def unique_id(self):
        raise NotImplementedError()

    def negate(self, negate: bool = True) -> Descriptor:
        raise NotImplementedError()

    def format(self, anchor: Optional["PrimaryNode"] = None) -> str:
        raise NotImplementedError()

    def __le__(self, other) -> bool:
        return False

    def __repr__(self) -> str:
        return object.__repr__(self)


class PolyDescription:
    """Represents a polyhierarchical description."""

    def __init__(
        self, anchor: "PrimaryNode", qualifiers: Optional[Iterable[Descriptor]] = None
    ) -> None:
        self.anchor: "PrimaryNode" = anchor
        self.qualifiers: List[Descriptor] = []

        if qualifiers is not None:
            self.update(qualifiers, on_conflict="raise")

    @property
    def descriptors(self) -> Sequence[Descriptor]:
        """Return all descriptors including the anchor and qualifiers."""
        return [self.anchor] + self.qualifiers

    def to_binary_raw(self) -> Mapping["_BaseRealNode", bool]:
        """Convert the description to a binary representation with nodes and their active state."""
        map: Mapping[_BaseRealNode, bool] = {}

        def handle_positive(node: _BaseRealNode):
            # Activate node and all precursors
            for precursor in node.precursors:
                if not isinstance(precursor, node.__class__):
                    continue

                if precursor._include_in_binary():
                    map[precursor] = True

                # Deactivate all siblings
                for sibling in precursor.siblings:
                    if not isinstance(sibling, node.__class__):
                        continue

                    if sibling._include_in_binary():
                        map[sibling] = False

        def handle_negative(node: _BaseRealNode):
            # Deactivate node and all successors
            for successor in node.walk():
                if not isinstance(successor, node.__class__):
                    continue

                if successor._include_in_binary():
                    map[successor] = False

        handle_positive(self.anchor)

        for qualifier in self.qualifiers:
            if isinstance(qualifier, _BaseRealNode):
                handle_positive(qualifier)
            elif isinstance(qualifier, NegatedRealNode):
                handle_negative(qualifier.node)
            else:
                raise ValueError(f"Unknown qualifier type: {type(qualifier)}")

        return map

    def to_binary_str(self) -> Mapping[str, bool]:
        """Convert the binary representation to a string representation."""
        return {str(k): v for k, v in self.to_binary_raw().items()}

    def to_multilabel(self, n_labels=None, fill_na: Any = -1) -> List:
        """Transform the description to a list of target values."""
        int_map = {
            n.index: v for n, v in self.to_binary_raw().items() if n.index is not None
        }

        if n_labels is None:
            n_labels = max(int_map.keys()) + 1

        return [int_map.get(i, fill_na) for i in range(n_labels)]

    def copy(self) -> "PolyDescription":
        """Create a copy of the current PolyDescription."""
        return PolyDescription(self.anchor, self.qualifiers)

    def _add_poly_description(
        self,
        other: "PolyDescription",
        on_conflict: TOnConflictLiteral,
    ):
        self.add(other.anchor, on_conflict)

        for qualifier in other.qualifiers:
            self.add(qualifier, on_conflict)

    def _add_primary(
        self,
        other: "PrimaryNode",
        on_conflict: TOnConflictLiteral,
    ):
        if self.anchor <= other:
            # anchor is empty or more general than other: replace
            self.anchor = other
            return

        if other <= self.anchor:
            # other is more general than self: do nothing
            return

        # Otherwise, other and self.anchor are in conflict
        if on_conflict == "replace":
            self.anchor = other
            return
        if on_conflict == "skip":
            return

        raise ConflictError(f"{self.anchor} and {other} are incompatible")

    def _add_tag(
        self,
        other: "TagNode",
        on_conflict: TOnConflictLiteral,
    ):
        # Check if other is already implied
        if other <= self:
            return

        # Remove existing qualifiers that are implied by `other`
        qualifiers = [q for q in self.qualifiers if not (q <= other)]

        if on_conflict == "replace":
            # Remove existing qualifiers that contradict `other` (!q is implied by other)
            qualifiers = [q for q in qualifiers if not (q.negate() <= other)]
        else:
            for q in qualifiers:
                if q.negate() <= other:
                    if on_conflict == "skip":
                        return

                    raise ConflictError(f"{q} and {other} are incompatible")

        self.qualifiers = qualifiers + [other]

    def _add_negated_primary(
        self,
        other: "NegatedRealNode[PrimaryNode]",
        on_conflict: TOnConflictLiteral,
    ):
        # Check if other is already implied
        if other <= self:
            return

        if other.node <= self.anchor:
            if on_conflict == "raise":
                raise ConflictError(f"{self.anchor} and {other} are incompatible")

            if on_conflict == "skip":
                return

            # Delete the precluded portion of the anchor
            assert other.node.parent is not None
            self.anchor = other.node.parent

        # Remove existing qualifiers implied by other
        qualifiers = [q for q in self.qualifiers if not (q <= other)]

        self.qualifiers = qualifiers + [other]

    def _add_negated_tag(
        self,
        other: "NegatedRealNode[TagNode]",
        on_conflict: TOnConflictLiteral,
    ):
        # Check if other is already implied
        if other <= self:
            return

        qualifiers = self.qualifiers

        if on_conflict == "replace":
            # Remove existing qualifiers that contradict `other`
            qualifiers = [q for q in qualifiers if not (q.negate() <= other)]
        else:
            for q in qualifiers:
                if q.negate() <= other:
                    if on_conflict == "skip":
                        return

                    raise ConflictError(f"{q} and {other} are incompatible")

        # Remove existing qualifiers that are implied by `other`
        qualifiers = [q for q in qualifiers if not (q <= other)]

        self.qualifiers = qualifiers + [other]

    def add(
        self,
        other: Union["PolyDescription", Descriptor],
        on_conflict: TOnConflictLiteral = "replace",
    ) -> "PolyDescription":
        """Add a descriptor or poly description to the current description."""
        if on_conflict not in ("replace", "raise", "skip"):
            raise ValueError(f"Unexpected value for on_conflict: {on_conflict}")

        if isinstance(other, PolyDescription):
            self._add_poly_description(other, on_conflict)

        elif isinstance(other, PrimaryNode):
            self._add_primary(other, on_conflict)

        elif isinstance(other, TagNode):
            self._add_tag(other, on_conflict)

        elif isinstance(other, NegatedRealNode):
            if isinstance(other.node, PrimaryNode):
                self._add_negated_primary(other, on_conflict)

            elif isinstance(other.node, TagNode):
                self._add_negated_tag(other, on_conflict)

            else:
                raise ValueError(
                    f"Unexpected type of NegatedQualifier.node: {type(other.node)}"
                )
        else:
            raise ValueError(f"Unexpected type of other: {type(other)}")

        return self

    def update(
        self,
        descriptors: Iterable[Descriptor],
        on_conflict: TOnConflictLiteral = "replace",
    ):
        for descriptor in descriptors:
            self.add(descriptor, on_conflict=on_conflict)

        return self

    def _remove_poly_description(self, other: "PolyDescription"):
        for descriptor in other.descriptors:
            self.remove(descriptor)

    def _remove_primary(self, other: "PrimaryNode"):
        if other <= self.anchor:
            # Delete the precluded portion of the anchor
            if other.parent is None:
                raise ValueError("Cannot remove root")

            self.anchor = other.parent

    def _remove_qualifier(self, other: "Descriptor"):
        # Replace qualifiers that imply "other" with their nearest ancestor that does not imply "other"

        new_qualifiers = []

        for q in self.qualifiers:
            if other <= q:
                # "other" is implied
                if (
                    isinstance(other, TagNode)
                    and isinstance(other.parent, TagNode)
                    and isinstance(other.parent.parent, TagNode)
                ):
                    # if other has a parent of the same type (TagNode): keep "other.parent" as the nearest ancestor that does not imply "other"
                    # (But don't keep group tags that don't carry information themselves.)
                    new_qualifiers.append(other.parent)
            else:
                # "other" not implied: keep "q"
                new_qualifiers.append(q)

        self.qualifiers = new_qualifiers

    def remove(self, other: Union["PolyDescription", Descriptor]):
        """Remove a descriptor or poly description from the current description."""
        if isinstance(other, PolyDescription):
            self._remove_poly_description(other)

        elif isinstance(other, PrimaryNode):
            self._remove_primary(other)

        elif isinstance(other, Descriptor):
            self._remove_qualifier(other)

        else:
            raise ValueError(f"Unexpected type of other: {type(other)}")

        return self

    def __le__(self, other) -> bool:
        if not isinstance(other, PolyDescription):
            return NotImplemented

        for d in self.descriptors:
            if not (d <= other):
                return False

        return True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, PolyDescription):
            return False

        return set(self.descriptors) == set(other.descriptors)

    def __hash__(self) -> int:
        return hash(frozenset(self.descriptors))

    def __repr__(self) -> str:
        return f"<{self.__class__.__name__} {self!s}>"

    def __str__(self) -> str:
        # Sort qualifiers alphabetically for stable lookup
        qualifiers = sorted([q.format(anchor=self.anchor) for q in self.qualifiers])

        return shlex.join([str(self.anchor)] + qualifiers)


class _BaseNode:
    """Base class for all nodes."""

    def __init__(
        self,
        name: str,
        parent: Optional["_BaseNode"],
    ) -> None:
        self.name = name
        self.parent = parent

    def set_parent(self, parent: Optional["_BaseNode"]):
        """Set the parent node."""
        self.parent = parent
        return self

    @functools.cached_property
    def precursors(self) -> Tuple["_BaseNode", ...]:
        """Return a tuple of all precursor nodes up to the root."""

        def _(node):
            while node is not None:
                yield node
                node = node.parent

        return tuple(_(self))[::-1]

    @property
    def siblings(self):
        """Return a tuple of sibling nodes."""
        if self.parent is None:
            return tuple()

        if isinstance(self.parent, (PrimaryNode, TagNode)):
            return tuple(c for c in self.parent.children if c is not self)

        return tuple()

    @functools.cached_property
    def path(self):
        """Return the path from the root to this node as a tuple of names."""
        return tuple(n.name for n in self.precursors)

    def format(self, anchor: Union["PrimaryNode", None] = None) -> str:
        """Format the node as a string relative to an optional anchor."""
        precursors = self.precursors

        if anchor is not None:
            # TagNodes are displayed relative to the next precursor of anchor
            if isinstance(self, TagNode):
                # Find first PrimaryNode in precursors
                tag_anchor = self.primary_parent
                if tag_anchor in anchor.precursors:
                    anchor = tag_anchor

            if anchor != self:
                try:
                    i = precursors.index(anchor)
                except:
                    pass
                else:
                    precursors = precursors[i + 1 :]

        def build():
            sep = ""
            for n in precursors:
                yield sep + n.name
                if isinstance(n, TagNode):
                    sep = ":"
                else:
                    sep = "/"

        return "".join(build())


class IndexProvider:
    """Class for providing unique indices for nodes."""

    def __init__(self) -> None:
        self.counter = itertools.count()
        self.taken: Set[int] = set()

    def remove(self, index):
        """Remove a specific index from the available pool."""
        if index in self.taken:
            raise ValueError(f"Index {index} is already taken")

        self.taken.add(index)

    def take(self):
        """Take the next available index."""
        while True:
            index = next(self.counter)
            if index not in self.taken:
                break

        self.taken.add(index)

        return index

    @property
    def n_labels(self):
        """Return the number of unique labels."""
        return max(self.taken) + 1


class _BaseRealNode(_BaseNode, Descriptor):
    """Base class for real nodes (nodes that have a real presence in the hierarchy)."""

    def __init__(
        self,
        name: str,
        parent: Optional["_BaseNode"],
        index: Optional[int],
        meta: Optional[Mapping],
    ) -> None:
        super().__init__(name, parent)
        self.index = index

        if meta is None:
            meta = {}

        self.meta = meta

    def to_dict(self) -> Dict[str, Any]:
        """Convert the node to a dictionary representation."""
        d: Dict[str, Any] = {}
        if self.index is not None:
            d["index"] = self.index
        return d

    @property
    def unique_id(self):
        return self.path

    def _get_all_children(self):
        raise NotImplementedError()

    def _include_in_binary(self):
        """Determine if the node should be included in the binary output."""
        return (type(self.parent) == type(self)) or not self._get_all_children()

    def fill_indices(self, index_provider: IndexProvider):
        """Fill the indices for the node and its children."""
        if self.index is None and self._include_in_binary():
            self.index = index_provider.take()
        for child in self._get_all_children():
            if isinstance(child, _BaseRealNode):
                child.fill_indices(index_provider)

    def walk(self) -> Iterator["_BaseRealNode"]:
        """Walk through the node and its children."""
        yield self
        for child in self._get_all_children():
            if isinstance(child, _BaseRealNode):
                yield from child.walk()

    def negate(self, negate: bool = True) -> "Descriptor":
        if negate:
            return NegatedRealNode(self)
        return self


TRealNode = TypeVar("TRealNode", bound=_BaseRealNode)


class NegatedRealNode(Descriptor, Generic[TRealNode]):
    """Represents a negated real node."""

    def __init__(self, node: TRealNode) -> None:
        # We cannot negate the root
        if node.parent is None:
            raise ValueError(f"Root node cannot be negated")

        self.node = node

    def format(self, anchor: Union["PrimaryNode", None] = None) -> str:
        """Format the negated node as a string."""
        return f"!{self.node.format(anchor)}"

    @property
    def unique_id(self):
        return ("!",) + self.node.path

    def negate(self, negate: bool = True) -> "Descriptor":
        if negate:
            return self.node
        return self

    def __le__(self, other) -> bool:
        if isinstance(other, NegatedRealNode):
            # !A <= !B iff B <= A
            return other.node <= self.node

        if isinstance(self.node, PrimaryNode):
            if isinstance(other, TagNode):
                return False

            if isinstance(other, PrimaryNode):
                # !A <= B if A is a sibling of any precursor of B
                for n in other.precursors[::-1]:
                    if any(s <= self.node for s in n.siblings):
                        return True

                return False

        if isinstance(self.node, TagNode):
            if isinstance(other, PrimaryNode):
                return False

            if isinstance(other, TagNode):
                # !A <= B iff A implies a sibling of any precursor of B
                for n in other.precursors[::-1]:
                    if not isinstance(n, TagNode):
                        break

                    if any(s <= self.node for s in n.siblings):
                        return True

                return False

        return Descriptor.__le__(self, other)


class TagNode(_BaseRealNode):
    """Represents a tag node."""

    parent: Union["PrimaryNode", "TagNode"]

    def __init__(
        self,
        name: str,
        parent: Union["PrimaryNode", "TagNode"],
        index: Optional[int],
        meta: Optional[Mapping] = None,
    ) -> None:
        super().__init__(name, parent, index, meta)

        self.children: List["TagNode"] = []

    @staticmethod
    def from_dict(
        name, data: Optional[Mapping], parent: Union["PrimaryNode", "TagNode"]
    ) -> "TagNode":
        """Create a TagNode from a dictionary representation."""
        if data is None:
            data = {}

        tag_node = TagNode(name, parent, data.get("index"), data.get("meta"))

        for child_name, child_data in data.get("children", {}).items():
            tag_node.add_child(TagNode.from_dict(child_name, child_data, tag_node))

        return tag_node

    def to_dict(self) -> Dict[str, Any]:
        """Convert the TagNode to a dictionary representation."""
        d = super().to_dict()
        if self.children:
            d["children"] = {c.name: c.to_dict() for c in self.children}

        return d

    def add_child(self, node: "TagNode"):
        """Add a child TagNode."""
        self.children.append(node)

    def _get_all_children(self):
        return self.children

    @functools.cached_property
    def primary_parent(self) -> Optional["PrimaryNode"]:
        """Return the primary parent (first parent that is a PrimaryNode) of the TagNode."""
        parent = self.parent
        while parent is not None:
            if isinstance(parent, PrimaryNode):
                return parent
            parent = parent.parent
        return None

    def _find_tag(self, name) -> "TagNode":
        if name == self.name:
            return self

        for child in self.children:
            try:
                return child._find_tag(name)
            except NodeNotFoundError:
                pass

        raise NodeNotFoundError(name)

    def find_tag(self, name_or_path: Union[str, Iterable[str]]) -> "TagNode":
        """Find a tag by name or path."""
        if isinstance(name_or_path, str):
            name_or_path = (name_or_path,)

        node = self
        while name_or_path:
            head, *name_or_path = name_or_path
            node = node._find_tag(head)

        return node

    def format_tree(self, extra_info=None) -> str:
        """Format the TagNode and its children as a tree."""
        name = self.name

        attrs = []
        if self.index is not None:
            attrs.append(f"index={self.index}")

        if self.meta:
            attrs.append(f"meta={self.meta}")

        if attrs:
            name = name + " (" + (", ".join(attrs)) + ")"

        if (self.index is not None) and (extra_info is not None):
            name += f" [{extra_info[self.index]}]"

        lines = [f"{name}:"]

        for child in self.children:
            lines.append(indent(child.format_tree(extra_info), "  "))

        return "\n".join(lines)

    @functools.cached_property
    def rivalling_children(self):
        """The set of directly rivalling descendants."""

        result: List[TagNode] = []
        for child in self.children:
            if child.index is not None:
                result.append(child)
            else:
                result.extend(child.rivalling_children)

        return result

    def __le__(self, other) -> bool:
        if isinstance(other, TagNode):
            return self in other.precursors

        if isinstance(other, PrimaryNode):
            return False

        if isinstance(other, NegatedRealNode):
            return False

        return Descriptor.__le__(self, other)


def _tokenize_expression_str(query_str: str):
    """Tokenize a string expression."""
    # Split into parts, then at : and / and separate off !
    return [
        tuple(filter(None, (re.split("/|:|(!)|(-)", part))))
        for part in shlex.split(query_str)
    ]


class VirtualNode(_BaseNode):
    """Represents a virtual node."""

    def __init__(
        self,
        name: str,
        parent: Optional["_BaseNode"],
        description: PolyDescription,
    ) -> None:
        super().__init__(name, parent)

        self.description = description

    def format_tree(self) -> str:
        """Format the virtual node as a tree."""
        return f"{self.name} -> {self.description!s}"

    def __repr__(self):
        return f"<{self.__class__.__name__} {self.format_tree()}>"


class PrimaryNode(_BaseRealNode):
    """Represents a primary node."""

    parent: Optional["PrimaryNode"]

    def __init__(
        self,
        name: str,
        parent: Optional["PrimaryNode"],
        index: Optional[int],
        alias: Optional[Iterable[str]] = None,
        meta: Optional[Mapping] = None,
    ) -> None:
        super().__init__(name, parent, index, meta)
        self.children: List["PrimaryNode"] = []
        self.tags: List[TagNode] = []
        self.virtuals: List[VirtualNode] = []

        if alias is None:
            alias = tuple()
        elif isinstance(alias, str):
            alias = (alias,)
        self.alias = tuple(alias)

    @staticmethod
    def from_dict(
        name, data: Optional[Mapping], parent: Optional["PrimaryNode"]
    ) -> "PrimaryNode":
        """Create a PrimaryNode from a dictionary representation."""
        if data is None:
            data = {}

        # Create node
        node = PrimaryNode(
            name, parent, data.get("index"), data.get("alias"), data.get("meta")
        )

        # Create tags
        for tag_name, tag_data in data.get("tags", {}).items():
            node.add_tag(TagNode.from_dict(tag_name, tag_data, node))

        # Create children (which may reference tags)
        for child_name, child_data in data.get("children", {}).items():
            node.add_child(PrimaryNode.from_dict(child_name, child_data, node))

        # Finally, create virtual nodes (which may reference tags and children)
        for virtual_name, virtual_description in data.get("virtuals", {}).items():
            try:
                if isinstance(virtual_description, str):
                    description = node.parse_description(virtual_description)
                else:
                    description = node.get_description(virtual_description)
                virtual_node = VirtualNode(virtual_name, node, description)
                node.add_virtual(virtual_node)
            except Exception as exc:
                raise ValueError(
                    f"Error parsing description {virtual_description!r} of virtual node '{node}/{virtual_name}'"
                ) from exc

        return node

    def to_dict(self):
        """Convert the PrimaryNode to a dictionary representation."""
        d = super().to_dict()
        if self.alias:
            if isinstance(self.alias, str) or len(self.alias) > 1:
                d["alias"] = self.alias
            else:
                d["alias"] = self.alias[0]

        if self.children:
            d["children"] = {c.name: c.to_dict() for c in self.children}

        if self.tags:
            d["tags"] = {t.name: t.to_dict() for t in self.tags}

        if self.virtuals:
            d["virtuals"] = {v.name: str(v.description) for v in self.virtuals}
        return d

    def _get_all_children(self):
        return self.children + self.tags + self.virtuals

    def add_child(self, node: "PrimaryNode"):
        """Add a child PrimaryNode."""
        self.children.append(node)
        return node

    def add_tag(self, node: TagNode):
        """Add a TagNode."""
        self.tags.append(node)
        return node

    def add_virtual(self, node: VirtualNode):
        """Add a VirtualNode."""
        self.virtuals.append(node)
        return node

    def _matches_name(self, name: str, with_alias: bool):
        """Check if the node matches the given name or alias."""
        if name == self.name:
            return True

        if with_alias:
            for alias in self.alias:
                if fnmatch.fnmatch(name, alias):
                    return True

        return False

    def find_all_primary(self, name: str, with_alias=False) -> List["PrimaryNode"]:
        """Find all PrimaryNode instances matching the given name."""
        matches: List[PrimaryNode] = []

        if self._matches_name(name, with_alias):
            matches.append(self)

        for child in self.children:
            matches.extend(child.find_all_primary(name, with_alias))

        return matches

    def _find_primary(self, name, with_alias=False) -> "PrimaryNode":
        """Return the first PrimaryNode from the current subtree with the given name."""

        matches = self.find_all_primary(name, with_alias)

        if not matches:
            raise NodeNotFoundError(name)

        # If we're matching with alias, multiple children can produce a match.
        # We therefore select the shortest match
        matches.sort(key=lambda n: len(n.precursors))

        return matches[0]

    def find_primary(
        self, name_or_path: Union[str, Iterable[str]], with_alias=False
    ) -> "PrimaryNode":
        """Find a primary node by name or path."""
        if isinstance(name_or_path, str):
            name_or_path = (name_or_path,)

        anchor = self
        while name_or_path:
            head, *name_or_path = name_or_path
            anchor = anchor._find_primary(head, with_alias)

        return anchor

    def find_tag(self, name_or_path: Union[str, Iterable[str]]) -> TagNode:
        """Find specified tag in this node or its parents."""
        for tag in self.tags:
            try:
                return tag.find_tag(name_or_path)
            except NodeNotFoundError:
                pass

        if self.parent is not None:
            return self.parent.find_tag(name_or_path)

        raise NodeNotFoundError(name_or_path)

    def find_virtual(self, name_or_path: Union[str, Iterable[str]]) -> VirtualNode:
        """Find specified virtual node in this node or its parents."""
        if isinstance(name_or_path, str):
            name_or_path = (name_or_path,)
        else:
            name_or_path = tuple(name_or_path)

        anchor = self
        while len(name_or_path) > 1:
            head, *name_or_path = name_or_path
            anchor = anchor._find_primary(head)

        name = name_or_path[0]

        for virtual in self.virtuals:
            if virtual.name.casefold() == name.casefold():
                return virtual

        if anchor.parent is not None:
            return anchor.parent.find_virtual(name)

        raise NodeNotFoundError(name)

    def format_tree(self, extra=None, virtuals=False) -> str:
        """Format the PrimaryNode and its children as a tree."""
        name = self.name

        attrs = []
        if self.index is not None:
            attrs.append(f"index={self.index}")

        if self.meta:
            attrs.append(f"meta={self.meta}")

        if attrs:
            name = name + " (" + (", ".join(attrs)) + ")"

        if self.index is not None and extra is not None:
            name += f" [{extra[self.index]}]"

        lines = [f"{name}::"]

        for child in self.children:
            lines.append(indent(child.format_tree(extra, virtuals), "  "))

        for tag in self.tags:
            lines.append(indent(tag.format_tree(extra), "  "))

        if virtuals:
            for virtual in self.virtuals:
                lines.append(indent(virtual.format_tree(), "  "))

        return "\n".join(lines)

    def find_real_node(
        self, name_or_path: Union[str, Iterable[str]], with_alias=False
    ) -> Union["PrimaryNode", "TagNode"]:
        """Find a real node (PrimaryNode or TagNode) by name or path."""
        try:
            return self.find_primary(name_or_path, with_alias)
        except NodeNotFoundError:
            pass

        return self.find_tag(name_or_path)

    def get_description(
        self,
        descriptors: Iterable[Union[str, Iterable[str]]],
        ignore_missing_intermediaries=False,
        with_alias=False,
        on_conflict: Literal["replace", "raise"] = "replace",
    ) -> PolyDescription:
        """
        Get a PolyDescription from a list of descriptors.

        Args:
            descriptors (Iterable[Union[str, Iterable[str]]]): The descriptors to parse.
            ignore_missing_intermediaries (bool, optional): Whether to ignore missing intermediaries. Defaults to False.
            with_alias (bool, optional): Whether to consider aliases. Defaults to False.
            on_conflict (Literal["replace", "raise"], optional): Conflict resolution strategy. Defaults to "replace".

        Returns:
            PolyDescription: The parsed PolyDescription.
        """
        # Turn into tuple
        descriptors = tuple(descriptors)

        def process_descriptors(
            description: PolyDescription, descriptors: Sequence, with_alias
        ):
            unmatched_parts = []

            # Requires descriptors to be a sequence
            while descriptors:
                head, *descriptors = descriptors

                if head and head[0] == "!":
                    negate = True
                    head = head[1:]
                else:
                    negate = False

                try:
                    node = description.anchor.find_real_node(head, with_alias)
                except NodeNotFoundError:
                    pass
                else:
                    if not unmatched_parts or isinstance(node, PrimaryNode):
                        description.add(node.negate(negate), on_conflict=on_conflict)

                        if unmatched_parts and not ignore_missing_intermediaries:
                            raise ValueError(
                                f"Unmatched parts {unmatched_parts} before current {head}"
                            )

                        # Reset unmatched parts
                        unmatched_parts.clear()
                        continue
                    # else:
                    # If a TagNode is found but there are unmatched_parts: Treat as not found

                try:
                    virtual = description.anchor.find_virtual(head)
                except NodeNotFoundError:
                    pass
                else:
                    description.add(virtual.description, on_conflict=on_conflict)

                    if unmatched_parts and not ignore_missing_intermediaries:
                        raise ValueError(f"Unmatched parts: {unmatched_parts}")

                    # Reset unmatched parts
                    unmatched_parts.clear()
                    continue

                unmatched_parts.append(head)
            return description, unmatched_parts

        description, unmatched_parts = process_descriptors(
            PolyDescription(self), descriptors, False
        )

        if unmatched_parts and with_alias:
            description, unmatched_parts = process_descriptors(
                description, unmatched_parts, True
            )

        if unmatched_parts:
            raise ValueError(f"Unmatched suffix: {unmatched_parts}")

        return description

    def parse_description(
        self,
        description: str,
        ignore_missing_intermediaries=False,
        with_alias=False,
        on_conflict: Literal["replace", "raise"] = "replace",
    ):
        """
        Parse a description string into a PolyDescription.

        Args:
            description (str): The description string to parse.
            ignore_missing_intermediaries (bool, optional): Whether to ignore missing intermediaries. Defaults to False.
            with_alias (bool, optional): Whether to consider aliases. Defaults to False.
            on_conflict (Literal["replace", "raise"], optional): Conflict resolution strategy. Defaults to "replace".

        Returns:
            PolyDescription: The parsed PolyDescription.
        """
        descriptors = _tokenize_expression_str(description)
        return self.get_description(
            descriptors, ignore_missing_intermediaries, with_alias, on_conflict
        )

    def union(self, other: "PrimaryNode"):
        """Return the union of the current node with another node."""
        if self in other.precursors:
            return other

        if other in self.precursors:
            return self

        raise ValueError(f"{self} and {other} are incompatible")

    @functools.cached_property
    def rivalling_children(self):
        """The set of directly rivalling descendants."""

        result: List[PrimaryNode] = []
        for child in self.children:
            if child.index is not None:
                result.append(child)
            else:
                result.extend(child.rivalling_children)

        return result

    def negate(self, negate: bool = True) -> "Descriptor":
        if negate and self.parent is None:
            return NeverDescriptor()

        return super().negate(negate)

    def __le__(self, other) -> bool:
        if isinstance(other, PrimaryNode):
            return self in other.precursors

        if isinstance(other, TagNode):
            return False

        if isinstance(other, NegatedRealNode):
            return False

        return Descriptor.__le__(self, other)


class Expression:
    """
    A class representing an expression for matching and modifying PolyDescription objects.

    Args:
        include (PolyDescription): A description to add / include in matches.
        exclude (List[PolyDescription]): A list of descriptions to remove / exclude from matches.
    """

    def __init__(
        self,
        include: PolyDescription,
        exclude: Sequence[Union[PolyDescription, Descriptor]],
    ):
        self.include = include
        self.exclude = exclude

    def match(self, description: PolyDescription) -> bool:
        """
        Check if a given PolyDescription matches the expression.

        A matches if A <= description
        !A matches if !A <= description
        -A matches if not (A <= description)
        -!A matches if not (!A <= description)

        Args:
            description (PolyDescription): The description to match.

        Returns:
            bool: True if the description matches, False otherwise.
        """
        if not (self.include <= description):
            return False

        for excl in self.exclude:
            if excl <= description:
                return False

        return True

    def apply(
        self,
        description: PolyDescription,
        on_conflict: TOnConflictLiteral = "replace",
    ) -> PolyDescription:
        """
        Apply the expression (in-place) to the given PolyDescription.

        A/!A: A/!A is added to the description.
        -A/-!A: A/!A is removed from the description.

        Args:
            description (PolyDescription): The description to modify.
            on_conflict (TOnConflictLiteral, optional): Conflict resolution strategy. Defaults to "replace".

        Returns:
            PolyDescription: The modified PolyDescription.
        """
        description.add(self.include, on_conflict)

        for excl in self.exclude:
            description.remove(excl)

        return description

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Expression):
            return NotImplemented

        return (self.include == other.include) and (self.exclude == other.exclude)

    def __repr__(self) -> str:
        return f"<{self.__class__.__name__}(include={self.include!r}, exclude={self.exclude!r})>"

    def __str__(self) -> str:
        exclude = []
        for excl in self.exclude:
            if isinstance(excl, Descriptor):
                exclude.append(f"-{excl.format(self.include.anchor)}")
            else:
                exclude.append(f"-({excl})")
        return str(self.include) + " " + shlex.join(exclude)


class PolyTaxonomy:
    """Taxonomy with multiple roots."""

    def __init__(self, root: PrimaryNode) -> None:
        self.root = root

    @classmethod
    def from_dict(cls, tree_dict: Mapping):
        """Create a PolyTaxonomy from a dictionary representation."""
        # Ensure single node
        (key, data), *remainder = list(tree_dict.items())

        if remainder:
            raise ValueError("Only one root node is allowed")

        root = PrimaryNode.from_dict(key, data, None)

        return cls(root)

    def to_dict(self) -> Mapping:
        """Convert the PolyTaxonomy to a dictionary representation."""
        return {self.root.name: self.root.to_dict()}

    def get_description(
        self,
        descriptors: Iterable[Union[str, Iterable[str]]],
        ignore_missing_intermediaries=False,
        with_alias=False,
        on_conflict: Literal["replace", "raise"] = "replace",
    ) -> PolyDescription:
        """
        Get a PolyDescription from a list of descriptors.

        Args:
            descriptors (Iterable[Union[str, Iterable[str]]]): The descriptors to parse.
            ignore_missing_intermediaries (bool, optional): Whether to ignore missing intermediaries. Defaults to False.
            with_alias (bool, optional): Whether to consider aliases. Defaults to False.
            on_conflict (Literal["replace", "raise"], optional): Conflict resolution strategy. Defaults to "replace".

        Returns:
            PolyDescription: The parsed PolyDescription.
        """
        return self.root.get_description(
            descriptors, ignore_missing_intermediaries, with_alias, on_conflict
        )

    def parse_description(
        self,
        description: str,
        ignore_missing_intermediaries=False,
        with_alias=False,
        on_conflict: Literal["replace", "raise"] = "replace",
    ) -> PolyDescription:
        """
        Parse a description string into a PolyDescription.

        Args:
            description (str): The description string to parse.
            ignore_missing_intermediaries (bool, optional): Whether to ignore missing intermediaries. Defaults to False.
            with_alias (bool, optional): Whether to consider aliases. Defaults to False.
            on_conflict (Literal["replace", "raise"], optional): Conflict resolution strategy. Defaults to "replace".

        Returns:
            PolyDescription: The parsed PolyDescription.
        """
        return self.root.parse_description(
            description, ignore_missing_intermediaries, with_alias, on_conflict
        )

    def parse_expression(self, expression_str: str) -> Expression:
        """Parse an expression string into an Expression object."""
        include = []
        exclude = []
        for part in _tokenize_expression_str(expression_str):
            if part and part[0] == "-":
                exclude.append(part[1:])
            else:
                include.append(part)

        include_dsc = self.get_description(include)

        exclude_descriptors = [
            include_dsc.anchor.get_description([e]).descriptors[-1] for e in exclude
        ]

        return Expression(include_dsc, exclude_descriptors)

    def get_node(self, node_name):
        """Get a node by name."""
        (path,) = _tokenize_expression_str(node_name)

        return self.root.find_real_node(path)

    def fill_indices(self):
        """Fill indices for all nodes in the taxonomy."""
        index_provider = IndexProvider()
        for node in self.root.walk():
            if isinstance(node, _BaseRealNode) and node.index is not None:
                index_provider.remove(node.index)

        self.root.fill_indices(index_provider)

        return index_provider.n_labels

    def format_tree(self, extra=None, virtuals=False):
        """Format the taxonomy as a tree."""
        return self.root.format_tree(extra, virtuals)

    def print_tree(self, extra=None, virtuals=False):
        """Print the taxonomy as a tree."""
        print(self.format_tree(extra, virtuals))

    def parse_probabilities(
        self,
        probabilities: Union[Mapping[int, float], Sequence[float]],
        *,
        baseline: Optional[PolyDescription] = None,
        thr_pos_abs=0.9,
        thr_pos_rel=0.25,
        thr_neg=0.1,
    ) -> PolyDescription:
        """
        Turn per-node probability scores (between 0 and 1) into a description.

        The algorithm proceeds along the hierarchy.
        If the score for a node exceeds the positive thresholds, the node is added to the
        description and the algorithm descends. If the score falls below the negative threshold,
        the negated node is added to the description.

        If a baseline description is supplied, it is updated with compatible predictions.
        Incompatible predictions will not be used, even if they obtain higher scores than any compatible prediction.

        Args:
            probabilities (Union[Mapping[int, float], Sequence[float]]): The probability scores for the nodes.
            baseline (Optional[PolyDescription], optional): The baseline description. Defaults to None.
            thr_pos_abs (float, optional): The absolute positive threshold. Defaults to 0.9.
            thr_pos_rel (float, optional): The relative positive threshold. Defaults to 0.25.
            thr_neg (float, optional): The negative threshold. Defaults to 0.1.

        Returns:
            PolyDescription: The resulting description.
        """
        if isinstance(probabilities, Mapping):
            probabilities = defaultdict(lambda: 0.5, probabilities)
        else:  # Sequence
            probabilities = defaultdict(
                lambda: 0.5, {i: k for i, k in enumerate(probabilities)}
            )

        if baseline is None:
            baseline = PolyDescription(self.root)

        description = baseline.copy()

        def handle_tag(tag: TagNode):
            # Gather all rival direct (and, in case of index==None, indirect) descendants of tag
            candidate_scores = [(n, probabilities[n.index]) for n in tag.rivalling_children]  # type: ignore

            # We need at least one candidate
            if not candidate_scores:
                return

            # Find winner
            candidate_scores.sort(key=op.itemgetter(1))
            winner, winner_score = candidate_scores[-1]

            # Check if winner is good enough
            good_enough = winner_score >= thr_pos_abs

            # If there are other candidates, apply thr_pos_rel
            if good_enough and len(candidate_scores) > 1:
                _, second_score = candidate_scores[-2]
                good_enough &= winner_score - second_score >= thr_pos_rel

            # If there is a good enough winner, store and descend
            if good_enough:
                description.add(winner, on_conflict="skip")
                handle_tag(winner)
            else:
                # Otherwise, at least store negatives
                for loser, score in candidate_scores:
                    if score <= thr_neg:
                        description.add(loser.negate(), on_conflict="skip")
                    else:
                        break

        def handle_primary(
            description: PolyDescription, node: PrimaryNode
        ) -> PolyDescription:
            # Gather all rival direct (and, in case of index==None, indirect) descendants of node
            candidate_scores = [(n, probabilities[n.index]) for n in node.rivalling_children]  # type: ignore

            # We need at least one candidate
            if not candidate_scores:
                return description

            # Find winner
            candidate_scores.sort(key=op.itemgetter(1))
            winner, score = candidate_scores[-1]

            # If there is a winner exceeding the threshold, store and descend
            if score >= thr_pos_abs:
                description.add(winner, on_conflict="skip")
                return handle_primary(description, winner)

            # Otherwise, at least store negatives
            for loser, score in candidate_scores:
                if score <= thr_neg:
                    description.add(loser.negate(), on_conflict="skip")
                else:
                    break

            return description

        description = handle_primary(description, description.anchor)

        # Once the anchor is predicted, predict additional tags
        primary_node: PrimaryNode
        for primary_node in description.anchor.precursors:  # type: ignore
            # Tags below a PrimaryNode are not in rivalry
            for tag in primary_node.tags:
                if tag.index is not None:
                    score = probabilities[tag.index]
                    if score <= thr_pos_abs:
                        if score < thr_neg:
                            description.add(tag.negate(), on_conflict="skip")
                        # Continue with next tag, do not descend
                        continue
                    else:  # score > thr_pos:
                        description.add(tag, on_conflict="skip")

                # Descend if index is None or score > thr_pos
                handle_tag(tag)

        return description

    def __eq__(self, other) -> bool:
        if not isinstance(other, PolyTaxonomy):
            return NotImplemented

        return self.root == other.root

    def __str__(self) -> str:
        return self.format_tree()
